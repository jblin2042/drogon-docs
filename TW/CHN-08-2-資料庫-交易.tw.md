[English](/ENG/ENG-08-2-Database-Transaction)

# 資料庫 - 交易

> **交易**是關聯式資料庫的重要特性，Drogon 透過 `Transaction` 類別提供交易支援。

`Transaction` 物件由 `DbClient` 建立，交易相關操作多數自動進行：

* 建立 `Transaction` 物件時，自動執行 `begin` 開始交易；
* `Transaction` 物件析構時，自動執行 `commit` 結束交易；
* 若中途發生導致交易失敗的例外，自動執行 `rollback` 回滾交易；
* 若交易已回滾，之後的 SQL 都會回傳例外（丟出例外或執行例外回呼）；

## 建立交易

交易建立介面由 `DbClient` 提供：

```c++
std::shared_ptr<Transaction> newTransaction(const std::function<void(bool)> &commitCallback = std::function<void(bool)>());
```

此介面回傳 `Transaction` 智慧指標，當指標失去所有持有者、物件析構時，交易即結束。`commitCallback` 用於回報交易提交是否成功，僅指示 `commit` 指令是否成功。若交易過程自動或手動回滾，則此回呼不會執行。通常 `commit` 都會成功，回呼參數為 true，僅特殊情況（如連線斷線）才會通知失敗，此時伺服器端交易狀態不確定，需特別處理。一般非關鍵業務可忽略此事件，故可不傳此參數（預設空回呼）。

交易需獨佔一個資料庫連線，故建立交易時，`DbClient` 會從連線池選一個空閒連線交給交易物件管理。若所有連線都在執行 SQL 或其他交易，此介面會阻塞直到有空閒連線。

框架也提供非阻塞的非同步介面：

```c++
void newTransactionAsync(const std::function<void(const std::shared_ptr<Transaction> &)> &callback);
```

此介面透過回呼回傳交易物件，不會阻塞執行緒，適合高併發場景，缺點是多一次回呼嵌套。請依需求選用。

## 交易介面

`Transaction` 介面與 `DbClient` 幾乎完全一致，僅有以下差異：

* `Transaction` 提供 `rollback()`，可隨時回滾交易（即使無錯誤、僅因業務邏輯需要），即使交易已自動回滾，再呼叫 `rollback()` 也無副作用。顯式呼叫 `rollback()` 可避免誤提交。
* 不可呼叫交易的 `newTransaction()`，因為目前框架不支援子交易。

`Transaction` 設計為 `DbClient` 子類，保持介面一致，也方便後續 ORM 使用。

目前框架未提供設定交易隔離等級的介面，隔離等級即資料庫預設值。

## 交易生命週期

交易物件的智慧指標除用戶持有外，若有未執行 SQL，框架也會持有，因此不必擔心尚有 SQL 未執行時物件被析構。智慧指標常在回呼中捕獲並使用，這是正常用法，不必擔心循環引用導致物件不會析構，框架會於回呼結束後清空內部回呼物件，打破循環引用。

## 範例

假設有任務表，使用者選取未處理任務並改為處理中，為避免併發競爭，使用 `Transaction`，程式如下：

```c++
{
    auto transPtr = clientPtr->newTransaction();
    transPtr->execSqlAsync( "select * from tasks where status=$1 for update order by time",
                            "none",
                            [=](const Result &r) {
                                if (r.size() > 0)
                                {
                                    std::cout << "Got a task!" << std::endl;
                                    *transPtr << "update tasks set status=$1 where task_id=$2"
                                              << "handling"
                                              << r[0]["task_id"].as<int64_t>()
                                              >> [](const Result &r)
                                                 {
                                                    std::cout << "Updated!";
                                                    ... do something about the task;
                                                 }
                                              >> [](const DrogonDbException &e)
                                                 {
                                                    std::cerr << "err:" << e.base().what() << std::end;
                                                 };
                                }
                                else
                                {
                                    std::cout << "No new tasks found!" << std::endl;
                                }
                            },
                            [](const DrogonDbException &e) {
                                std::cerr << "err:" << e.base().what() << std::end;
                            });
}
```

本例用 select for update 避免併發修改，update 在 select 結果回呼中執行，形成一次嵌套。最外層大括號限定 transPtr 作用範圍，確保 SQL 執行完即釋放、結束交易。

# 下一步：[ORM](/CHN/CHN-08-3-数据库-ORM)
